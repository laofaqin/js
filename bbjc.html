<html>
<head>
  <title>闭包和继承</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (zh-CN, DDL); Windows/6.3.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2552"/>

<div>
<span><div><span style="font-size: 14pt; font-family: 微软雅黑; font-weight: bold;">第一节</span></div><div><span style="font-family: 微软雅黑;">1.什么是闭包</span></div><div>闭包就是能够读取其他函数内部变量的函数。在JS中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解为”定义在一个函数内部的函数”。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function fn() {</div><div>     var b = 1;</div><div><br/></div><div>     //闭包</div><div>     function box() {</div><div>          //</div><div>          console.log(b);</div><div>     }</div><div><br/></div><div>     //返回一个函数，这个函数就是一个闭包</div><div>     return box;</div><div><br/></div><div>}</div><div><br/></div><div>//res 就是 box 函数</div><div>var res = fn();</div><div><br/></div><div>//2秒以后调用res函数，还是能打印b的值,闭包能让局部变量常驻内存</div><div>setTimeout(function() {</div><div>     res();</div><div><br/></div><div>}, 2000);</div><div><br/></div></div><div><br/></div><div><span style="font-family: 微软雅黑;">2.闭包的特点</span></div><div style="margin-left:40px;">1：可以读取函数内部的变量。</div><div style="margin-left:80px;">变量的作用域无非就是两种：全局变量和局部变量。</div><div style="margin-left:80px;">JS语言的特殊之处，就在于函数内部可以直接读取全局变量。另一方面，函数外部自然无法读取函数内的局部变量</div><div style="margin-left:40px;">2：让这些变量的值始终保存在内存中。</div><div><span style="font-family: 微软雅黑;">闭包的应用场景</span></div><div style="margin-left:40px;">1：函数作为返回值。</div><div style="margin-left:40px;"><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function box() {</div><div><br/></div><div>     var n = 1; //</div><div>     function cox() {</div><div>          n++;</div><div>          return n;</div><div>     }</div><div><br/></div><div>     return cox;</div><div><br/></div><div>}</div><div>//res 就是一个闭包 ，n像是一个全局变量</div><div>var res = box();</div><div><br/></div><div>console.log(res()); //2</div><div>console.log(res()); //3</div></div><div style="margin-left:40px;"><br/></div><div style="margin-left:40px;">2：函数作为参数被传递</div><div style="margin-left:40px;">回调函数</div><div><span style="font-family: 微软雅黑;"><span style="font-size: 14pt; font-family: 微软雅黑; font-weight: bold;">第二节</span></span></div><ol><li><div><span style="font-family: 微软雅黑;">掌握闭包的特点和原理</span></div></li><li><div><span style="font-family: 微软雅黑;">掌握闭包的应用场景</span></div></li></ol><div><span style="font-family: 微软雅黑;"><span style="font-size: 14pt; font-family: 微软雅黑; font-weight: bold;">第三节</span></span></div><ul><li><span style="font-family: 微软雅黑;">构造函数继承</span></li></ul><div>本质是在子类中，调用父类构造函数，从而让子类拥有父类的属性和方法</div><div><img src="闭包和继承_files/Image.png" type="image/png" data-filename="Image.png" style="height:auto;" width="403"/></div><ul><li><span style="font-family: 微软雅黑;">call/apply方法</span></li></ul><div>all和apply都是为了改变某个函数运行时的context即上下文而存在的，换句话说，就是为了改变函数内部this的指向。</div><div>二者作用完全一样，只是接受参数的方式不太一样。</div><div>fn.call(obj, arg1, arg2 [, argN]);</div><div> call方法是Function类中的方法</div><div>  call方法的第一个参数的值赋值给类(即方法)中出现的this</div><div>  call方法的第二个参数开始依次赋值给类(即方法)所接受的参数</div><div>注意：调用函数的call或者apply方法相当于是调用函数</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>              function box(a,b){</div><div>                   console.log(this,a,b)</div><div>              }</div><div><br/></div><div>              var arr = [1111];</div><div><br/></div><div>              //使用arr改变的 box中this</div><div>              box.call(arr,1,3)</div></div><div><br/></div><div>fn,.apply(obj, [arg1, arg2,…, argN]);</div><div>apply以数组的形式传参，call是以列表的形式</div><div>  apply方法接受2个参数，</div><div>    A、第一个参数与call方法的第一个参数一样，即赋值给类(即方法)中出现的this</div><div>    B、第二个参数为数组类型，这个数组中的每个元素依次赋值给类(即方法)所接受的参数</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>              function box(a,b){</div><div>                   console.log(this,a,b)</div><div>              }</div><div><br/></div><div>              var arr = [1111];</div><div><br/></div><div>              //使用arr改变的 box中this</div><div>              box.apply(arr,[2,4])</div></div><div><br/></div><div>利用apply使用math的min和max 方法</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>              var arr1 = [1,2,3,4,5,6,6,45,45];</div><div>              console.log(Math.min.apply(null,arr1));</div><div>              console.log(Math.max.apply(null,arr1));</div></div><div><br/></div><ul><li><span style="font-family: 微软雅黑;">call/apply</span><span style="font-family: 微软雅黑;">继承</span></li></ul><div><img src="闭包和继承_files/Image [1].png" type="image/png" data-filename="Image.png" style="height:auto;" width="320"/></div><div><br/></div><div><img src="闭包和继承_files/Image [2].png" type="image/png" data-filename="Image.png" style="height:auto;" width="305"/></div><ul><li><span style="font-family: 微软雅黑;">prototype原型</span></li></ul><div>大部分面向对象的编程语言，都以“类”（class）为基础，实现对象的继承。JavaScript 语言不是如此，它的对象继承以“原型对象”（prototype）为基础。</div><div><br/></div><div>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Cat(name, color) {</div><div>  this.name = name;</div><div>  this.color = color;</div><div>  this.meow = function () {</div><div>    console.log('喵喵');</div><div>  };}</div><div>var cat1 = new Cat('大毛', '白色');</div><div>var cat2 = new Cat('二毛', '黑色');</div><div>cat1.meow === cat2.meow// false</div></div><div><br/></div><div>     上面代码中，Cat函数是一个构造函数，函数内部定义了name属性和color属性，所有实例对象（上例是cat1）都会生成这两个属性，即这两个属性会定义在实例对象上面。</div><div>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</div><div>     cat1和cat2是同一个构造函数的两个实例，它们都具有meow方法。由于meow方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个meow方法。这既没有必要，又浪费系统资源，因为所有meow方法都是同样的行为，完全应该共享。</div><div><br/></div><div>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</div><div><br/></div><ul><li>prototype的概念</li></ul><div>每一个构造函数都有一个prototype属性，这个属性会在生成实例的时候，成为实例对象的原型对象。</div><div><br/></div><div>JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。</div><div>一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。null也可以充当原型，区别在于它没有自己的原型对象。</div><div><br/></div><div>JavaScript 继承机制的设计就是，原型的所有属性和方法，都能被子对象共享。</div><div><br/></div><div>下面，先看怎么为对象指定原型。</div><div>每一个构造函数都有一个prototype属性，这个属性会在生成实例的时候，成为实例对象的原型对象</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Animal(name) {</div><div>  this.name = name;</div><div>}</div><div>Animal.prototype.color = 'white';</div><div>var cat1 = new Animal('大毛');</div><div>var cat2 = new Animal('二毛');</div><div>cat1.color // 'white'</div><div>cat2.color // 'white'</div></div><div>上面代码中，构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。原型对象上添加一个color属性，结果，实例对象都继承了该属性。</div><div>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</div><div><span style="color: rgb(51, 51, 51);"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="font-size: 12px;"><br/></span></span></span></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>Animal.prototype.color = 'yellow';</div><div>cat1.color // &quot;yellow&quot;</div><div>cat2.color // &quot;yellow&quot;</div></div><div><br/></div><div>上面代码中，原型对象的color属性的值变为yellow，两个实例对象的color属性立刻跟着变了。这是因为实例对象其实没有color属性，都是读取原型对象的color属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到构造函数的prototype属性指向的对象，去寻找该属性或方法。这就是原型对象的特殊之处。</div><div>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</div><div><br/></div><div>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象</div><div><br/></div><div><img src="闭包和继承_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><ul><li><span style="font-family: 微软雅黑;">原型链继承</span></li></ul><div><br/></div><div>原型链</div><div>对象的属性和方法，有可能定义在自身，也有可能定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。</div><div><br/></div><div>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性。那么，Object.prototype对象有没有它的原型呢？回答是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。</div><div><br/></div><div><br/></div><div>“原型链”的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。</div><div><br/></div><div>举例来说，如果让某个函数的prototype属性指向一个数组，就意味着该函数可以当作数组的构造函数，因为它生成的实例对象都可以通过prototype属性调用数组方法</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>var MyArray = function () {</div><div>};</div><div>//</div><div>MyArray.prototype = new Array();</div><div><br/></div><div>var mine = new MyArray();</div><div>mine.push(1, 2, 3);</div><div>mine.length //</div></div><div><br/></div><div>上面代码中，mine是构造函数MyArray的实例对象，由于MyArray的prototype属性指向一个数组实例，使得mine可以调用数组方法（这些方法定义在数组实例的prototype对象上面）。</div><div><br/></div><div>原型链继承就是利用这个原理</div><div>将一个构造函数的原型指向另一个构造函数的实例对象来实现继承。</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Box() {                            //Box构造</div><div>    this.name = 'Lee';</div><div>}</div><div>function Desk() {                            //Desk构造</div><div>    this.age = 100;</div><div>}</div><div>Desk.prototype = new Box();                    //Desc继承了Box，通过原型，形成链条</div><div>var desk = new Desk();</div><div>alert(desk.age);</div><div>alert(desk.name);                            //得到被继承的属性</div></div><div><br/></div><div><br/></div><ul><li><span style="font-family: 微软雅黑;">混合继承</span></li></ul><div>结合使用原型链与构造函数继承 </div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>function Box(age) {</div><div>    this.name = 'Lee'</div><div>    this.age = age;</div><div><br/></div><div>}</div><div><br/></div><div>Box.prototype.run = function () {               </div><div>        return this.name + this.age;</div><div>};</div><div><br/></div><div>function Desk(age) {</div><div>    Box.call(this, age);      //构造函数继承继承了 name 和age 属性</div><div><br/></div><div>}</div><div><br/></div><div>Desk.prototype = new Box();        //原型链继承  run方法</div><div><br/></div><div>var desk = new Desk(100);</div><div>alert(desk.run());</div></div><div><br/></div><div><br/></div><div><span style="font-family: 微软雅黑;"><span style="font-size: 14pt; font-family: 微软雅黑; font-weight: bold;">第四节</span></span></div><div><span style="font-family: 微软雅黑;">     掌握继承的原理</span></div><div><span style="font-family: 微软雅黑;"><span style="font-size: 14pt; font-family: 微软雅黑; font-weight: bold;">第五节：强化练习</span></span></div><div>    掌握es5继承，回顾es6继承</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 